<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Futebol de Botão Online</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition: none !important;
  transform: none !important;
  animation: none !important;
}

body {
  background: #4B0082;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}

#lobby {
  background: rgba(255, 255, 255, 0.98);
  padding: 30px 50px;
  border-radius: 16px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
  text-align: center;
  width: 500px;
}

#lobby h2 {
    font-size: 36px;
    font-weight: 700;
    color: #1c1c1e;
    margin-bottom: 20px;
}

#room-list {
    list-style: none;
    padding: 0;
    margin-bottom: 20px;
    max-height: 200px;
    overflow-y: auto;
}

#room-list li {
    background: #f0f0f0;
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

#room-list button {
    background-color: #007aff;
    color: white;
    padding: 5px 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#create-room-form input {
    display: block;
    width: 100%;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
    border: 1px solid #ccc;
}

#create-room-form button {
    background-color: #34c759;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    width: 100%;
}

#game-container {
  position: relative;
  display: none; /* Inicia oculto */
  border-radius: 30px;
  overflow: hidden;
  box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.08);
}

canvas {
  background: #000000;
  display: block;
  margin: 0;
  border-radius: 30px;
  border: none;
}

#goal-display {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 100px;
  font-weight: 800;
  color: #ffffff;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  opacity: 0;
  pointer-events: none;
  z-index: 1000;
  white-space: nowrap;
  padding: 10px 25px;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 18px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  letter-spacing: -1px;
  transition: opacity 0.4s ease-in-out;
}

#score-display {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%) !important;
  font-size: 44px;
  font-weight: 600;
  color: #ffffff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  z-index: 998;
  background: rgba(0, 0, 0, 0.6);
  padding: 5px 18px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  white-space: nowrap;
}

#victory-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  visibility: hidden;
  z-index: 2000;
}

#victory-overlay.active {
  opacity: 1;
  visibility: visible;
}

#victory-card {
  background: rgba(255, 255, 255, 0.98);
  padding: 30px 50px;
  border-radius: 16px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
  text-align: center;
  transform: scale(1);
  opacity: 0;
  border: 1px solid rgba(255, 255, 255, 0.9);
}

#victory-overlay.active #victory-card {
  opacity: 1;
}

#victory-card h2 {
  font-size: 52px;
  font-weight: 700;
  color: #1c1c1e;
  margin-bottom: 15px;
  letter-spacing: -0.5px;
}

#victory-card p {
  font-size: 24px;
  color: #3a3a3c;
  margin-bottom: 25px;
  font-weight: 400;
}

#restart-button {
  background-color: #007aff;
  color: white;
  font-size: 20px;
  font-weight: 600;
  padding: 12px 30px;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 122, 255, 0.1);
}

#restart-button:hover {
  background-color: #0060e6;
}

#restart-button:active {
  background-color: #0050c0;
}

  </style>
</head>
<body>
    <div id="lobby">
        <h2>Salas Disponíveis</h2>
        <ul id="room-list"></ul>
        <form id="create-room-form">
            <input type="text" id="room-name" placeholder="Nome da Sala" required>
            <input type="password" id="room-password" placeholder="Senha (opcional)">
            <button type="submit">Criar Sala</button>
        </form>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="1800" height="1080"></canvas>
        <div id="goal-display">gooooooal!</div>
        <div id="score-display">0 - 0</div>
    </div>

<div id="victory-overlay">
  <div id="victory-card">
    <h2 id="victory-message"></h2>
    <p id="victory-subtitle">Aguarde para jogar novamente.</p>
    <button id="restart-button">Jogar Novamente</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>

const lobby = document.getElementById('lobby');
const roomList = document.getElementById('room-list');
const createRoomForm = document.getElementById('create-room-form');
const roomNameInput = document.getElementById('room-name');
const roomPasswordInput = document.getElementById('room-password');
const gameContainer = document.getElementById('game-container');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const goalDisplay = document.getElementById('goal-display');
const scoreDisplay = document.getElementById('score-display');
const victoryOverlay = document.getElementById('victory-overlay');
const victoryMessage = document.getElementById('victory-message');
const restartButton = document.getElementById('restart-button');

let pieces = [];
let ball = { x: 0, y: 0, radius: 30, angle: 0 };
let myTeam = -1;
let gameStarted = false;
let rgbHue = 0;
let messageText = '';
let countdownValue = '';

const socket = io({
  transports: ["websocket"]
});

socket.on('connect', () => {
    console.log('Conectado ao servidor!', socket.id);
});

socket.on('roomList', (rooms) => {
    roomList.innerHTML = '';
    for (const roomName in rooms) {
        const room = rooms[roomName];
        if (room.playerCount < 2) {
            const li = document.createElement('li');
            li.textContent = `${roomName} (${room.playerCount}/2)`;
            const joinButton = document.createElement('button');
            joinButton.textContent = 'Entrar';
            joinButton.onclick = () => {
                const password = room.hasPassword ? prompt('Digite a senha da sala:') : '';
                if (password !== null) {
                    socket.emit('joinRoom', { roomName, password });
                }
            };
            li.appendChild(joinButton);
            roomList.appendChild(li);
        }
    }
});

createRoomForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const roomName = roomNameInput.value;
    const password = roomPasswordInput.value;
    socket.emit('createRoom', { roomName, password });
});

socket.on('joinError', (message) => {
    alert(message);
});

socket.on('waitingForOpponent', () => {
    lobby.style.display = 'none';
    gameContainer.style.display = 'inline-block';
    messageText = "Procurando um oponente...";
});

socket.on('gameStart', (data) => {
    myTeam = data.team;
    pieces = data.state.pieces;
    ball = data.state.ball;
    updateScoreDisplay(data.state.scoreRed, data.state.scoreBlue);
    lobby.style.display = 'none';
    gameContainer.style.display = 'inline-block';
    messageText = myTeam === 0 ? "Você é o time VERMELHO" : "Você é o time AZUL";
});

socket.on('gameState', (serverState) => {
    if (!gameStarted && serverState.gameStarted) {
        gameStarted = true;
        messageText = '';
    }
    pieces = serverState.pieces;
    ball = serverState.ball;
    updateScoreDisplay(serverState.scoreRed, serverState.scoreBlue);
});

socket.on('countdown', (value) => {
    gameStarted = false;
    countdownValue = value;
    messageText = value > 0 ? value : 'VAI!';
});

socket.on('goalScored', () => {
    showGoalAnimation();
});

socket.on('gameOver', (data) => {
    gameStarted = false;
    showVictoryScreen(data.winner);
});

socket.on('opponentLeft', () => {
    gameStarted = false;
    showVictoryScreen("Seu oponente desconectou.");
});

const maxDrag = 195;
let dragging = false;
let dragStart = null;
let selected = null;
let dragVector = null;

canvas.addEventListener('pointerdown', e => {
  if (!gameStarted || myTeam === -1) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  for (let p of pieces) {
    if (p.team === myTeam && Math.hypot(p.x - mx, p.y - my) < p.radius) {
        dragging = true;
        dragStart = { x: mx, y: my };
        selected = p;
        break;
    }
  }
});

document.addEventListener('pointermove', e => {
  if (!dragging || !selected) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  let dx = dragStart.x - mx;
  let dy = dragStart.y - my;
  const len = Math.hypot(dx, dy);

  if (len > maxDrag) {
    dx = dx / len * maxDrag;
    dy = dy / len * maxDrag;
  }
  dragVector = { dx, dy };
});

document.addEventListener('pointerup', e => {
  if (!dragging || !selected || !dragVector) return;

  socket.emit('playerAction', {
    pieceId: selected.id,
    vx: dragVector.dx * 0.35,
    vy: dragVector.dy * 0.35
  });

  dragging = false;
  dragStart = null;
  selected = null;
  dragVector = null;
});

restartButton.addEventListener('click', () => {
    window.location.reload();
});

function showGoalAnimation() {
    goalDisplay.style.opacity = 1;
    setTimeout(() => { goalDisplay.style.opacity = 0; }, 1500);
}

function showVictoryScreen(winningTeam) {
    victoryMessage.textContent = `${winningTeam} Venceu!`;
    victoryOverlay.classList.add('active');
}

function updateScoreDisplay(scoreRed, scoreBlue) {
  scoreDisplay.textContent = `${scoreRed} - ${scoreBlue}`;
}

const redPlayerImages = [ 'https://i.ibb.co/23JJbw5v/image.png', 'https://pbs.twimg.com/media/GlU_8qAWMAA7aL7?format=jpg&name=large', 'https://i.ibb.co/q3jF38mH/image.png', 'https://pbs.twimg.com/profile_images/1938488713031651334/PWEMZVCL_400x400.jpg', 'https://i.ibb.co/0jSLSP83/image.png', 'https://i.ibb.co/LD4s55Nt/image.png', 'https://i.ibb.co/VY1Fv0c9/image.png', 'https://i.ibb.co/KcXCmqjf/image.png', 'https://i.ibb.co/hJq1tbTs/image.png', 'https://i.ibb.co/rGvJJQcM/image.png', 'https://i.ibb.co/B2jJ7Z8F/image.png' ];
const bluePlayerImages = [ 'https://i.ibb.co/v6xJM1vr/image.png', 'https://i.ibb.co/fVqBwtp8/image.png', 'https://i.ibb.co/R420q78C/image.png', 'https://i.ibb.co/wFcp2CwG/image.png', 'https://i.ibb.co/prxv8nfr/image.png', 'https://i.ibb.co/prLhZrkr/image.png', 'https://i.ibb.co/8gvJnRnV/image.png', 'https://i.ibb.co/gMK9ccJ8/image.png', 'https://i.ibb.co/gLg8DLht/image.png', 'https://pbs.twimg.com/media/GuLYIi2bYAAyszK?format=jpg&name=small', 'https://i.ibb.co/23QMdnRN/image.png' ];
const soccerBallImage = new Image();
soccerBallImage.src = 'https://em-content.zobj.net/source/apple/419/soccer-ball_26bd.png';
const logo = new Image();
logo.src = 'https://files.svgcdn.io/token-branded/monad.png';

let redPlayerImageObjects = redPlayerImages.map(url => { const img = new Image(); img.src = url; return img; });
let bluePlayerImageObjects = bluePlayerImages.map(url => { const img = new Image(); img.src = url; return img; });

function draw() {
    rgbHue = (rgbHue + 5) % 360;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const wallThickness = 10;
    const goalHeight = 300 * 1.10;
    const goalWidth = 10;
    ctx.fillStyle = '#2c2c2e';
    ctx.fillRect(0, 0, canvas.width, wallThickness);
    ctx.fillRect(0, canvas.height - wallThickness, canvas.width, wallThickness);
    ctx.fillRect(0, 0, wallThickness, canvas.height / 2 - goalHeight / 2);
    ctx.fillRect(0, canvas.height / 2 + goalHeight / 2, wallThickness, canvas.height / 2 - goalHeight / 2);
    ctx.fillRect(canvas.width - wallThickness, 0, wallThickness, canvas.height / 2 - goalHeight / 2);
    ctx.fillRect(canvas.width - wallThickness, canvas.height / 2 + goalHeight / 2, wallThickness, canvas.height / 2 - goalHeight / 2);
    
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, wallThickness);
    ctx.lineTo(canvas.width / 2, canvas.height - wallThickness);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 100, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 8, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    const penaltyAreaWidth = 200;
    const penaltyAreaHeight = 500;
    ctx.strokeRect(wallThickness, canvas.height / 2 - penaltyAreaHeight / 2, penaltyAreaWidth, penaltyAreaHeight);
    ctx.strokeRect(canvas.width - wallThickness - penaltyAreaWidth, canvas.height / 2 - penaltyAreaHeight / 2, penaltyAreaWidth, penaltyAreaHeight);
    const smallAreaWidth = 100;
    const smallAreaHeight = 250;
    ctx.strokeRect(wallThickness, canvas.height / 2 - smallAreaHeight / 2, smallAreaWidth, smallAreaHeight);
    ctx.strokeRect(canvas.width - wallThickness - smallAreaWidth, canvas.height / 2 - smallAreaHeight / 2, smallAreaWidth, smallAreaHeight);
    ctx.beginPath();
    ctx.arc(wallThickness + penaltyAreaWidth * 0.7, canvas.height / 2, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(canvas.width - wallThickness - penaltyAreaWidth * 0.7, canvas.height / 2, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(wallThickness + penaltyAreaWidth * 0.7, canvas.height / 2, 100, Math.PI * 0.7, Math.PI * 1.3);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width - wallThickness - penaltyAreaWidth * 0.7, canvas.height / 2, 100, Math.PI * -0.3, Math.PI * 0.3);
    ctx.stroke();

    ctx.fillStyle = 'rgba(150, 0, 255, 0.3)';
    ctx.fillRect(wallThickness, canvas.height / 2 - goalHeight / 2, goalWidth, goalHeight);
    ctx.fillRect(canvas.width - wallThickness - goalWidth, canvas.height / 2 - goalHeight / 2, goalWidth, goalHeight);

    if (logo.complete) { const logoScale = 1.40; const logoWidth = 300 * logoScale; const logoHeight = logoWidth * (logo.height / logo.width); const centerX = canvas.width / 2 - logoWidth / 2; const centerY = canvas.height / 2 - logoHeight / 2; ctx.globalAlpha = 0.8; ctx.drawImage(logo, centerX, centerY, logoWidth, logoHeight); ctx.globalAlpha = 1.0; }
    
    if(pieces && pieces.length > 0) {
        for (const p of pieces) {
            const img = p.team === 0 ? redPlayerImageObjects[p.id % redPlayerImageObjects.length] : bluePlayerImageObjects[p.id % bluePlayerImageObjects.length];
            ctx.lineWidth = 5;
            ctx.shadowBlur = 10;
            if (p.team === 0) { ctx.strokeStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; }
            else { ctx.strokeStyle = '#00ffff'; ctx.shadowColor = '#00ffff'; }
            ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.stroke();
            ctx.shadowBlur = 0; ctx.shadowColor = 'transparent';
            if (img && img.complete) {
                ctx.save();
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2, true); ctx.clip();
                const imgSize = p.radius * 2; const imgX = p.x - p.radius; const imgY = p.y - p.radius;
                ctx.drawImage(img, imgX, imgY, imgSize, imgSize);
                ctx.restore();
            }
        }
    }
    
    if (ball && soccerBallImage.complete) {
        ctx.save(); ctx.translate(ball.x, ball.y); ctx.rotate(ball.angle);
        const ballImgSize = ball.radius * 2;
        ctx.drawImage(soccerBallImage, -ballImgSize / 2, -ballImgSize / 2, ballImgSize, ballImgSize);
        ctx.restore();
    }
    
    if (dragging && selected && dragVector) {
        const { dx, dy } = dragVector;
        const len = Math.hypot(dx, dy);
        if(len > 0) {
            const unitX = dx / len; const unitY = dy / len;
            const lineLen = Math.min(len, maxDrag) * 1.5;
            const arrowOffset = 15;
            const endX = selected.x + unitX * (lineLen + arrowOffset);
            const endY = selected.y + unitY * (lineLen + arrowOffset);
            ctx.strokeStyle = `hsl(${rgbHue}, 100%, 70%)`; ctx.lineWidth = 12; ctx.lineCap = 'round';
            ctx.shadowBlur = 25; ctx.shadowColor = `hsl(${rgbHue}, 100%, 60%)`;
            ctx.beginPath(); ctx.moveTo(selected.x, selected.y);
            ctx.lineTo(selected.x + unitX * lineLen, selected.y + unitY * lineLen);
            ctx.stroke();
            ctx.shadowBlur = 0; ctx.shadowColor = 'transparent'; ctx.lineCap = 'butt';
            const arrowSize = 35;
            ctx.beginPath(); ctx.moveTo(endX, endY);
            ctx.lineTo( endX - unitX * arrowSize - unitY * arrowSize * 0.4, endY - unitY * arrowSize + unitX * arrowSize * 0.4 );
            ctx.lineTo( endX - unitX * arrowSize + unitY * arrowSize * 0.4, endY - unitY * arrowSize - unitX * arrowSize * 0.4 );
            ctx.closePath(); ctx.fillStyle = `hsl(${rgbHue}, 100%, 70%)`; ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 3; ctx.stroke();
        }
    }

    if (messageText) {
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(canvas.width / 2 - 350, canvas.height / 2 - 70, 700, 140);
      ctx.fillStyle = 'white';
      ctx.font = '700 52px "Inter"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(messageText, canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }

    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
